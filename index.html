<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TS Angel Forex AI ‚Äî Full</title>
  <style>
    html,body{margin:0;padding:0;overflow-x:hidden;font-family:Arial,sans-serif;background:black;color:white;text-transform:uppercase}
    canvas#starfield{position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1}
    body{text-align:center;padding:20px}
    h1{color:#00ffe7;animation:neon-flicker 1.5s infinite}
    #timeDisplay{font-size:1.1rem;color:#ffcc00;animation:neon-flicker 2s infinite}
    select,button{padding:12px 20px;margin:10px;font-size:1rem;border-radius:6px;background:#111;color:#00ffea;border:2px solid #00ffea;cursor:pointer;animation:glow-pulse 2s infinite}
    button:hover{background:#00ffea;color:black}
    iframe{width:100%;height:500px;border:none;margin-top:25px;border-radius:10px;box-shadow:0 0 20px #00ffe7;animation:glow-pulse 3s infinite}
    .signal-box{margin-top:25px;background:#111;padding:20px;border-radius:10px;font-size:1.05rem;color:#ffcc00;animation:glow-pulse 1.5s infinite;white-space:pre-line;line-height:1.4}
    .watermark{margin-top:40px;font-size:1.1rem;color:#00ffe7;animation:neon-flicker 2s infinite}
    .levels a{color:#00ffea;text-decoration:underline;cursor:pointer;margin:0 6px;display:inline-block}
    @keyframes neon-flicker{0%,100%{text-shadow:0 0 5px #0ff,0 0 10px #0ff,0 0 20px #0ff}50%{text-shadow:0 0 2px #0ff,0 0 5px #0ff}}
    @keyframes glow-pulse{0%,100%{box-shadow:0 0 10px #00ffe7,0 0 20px #00ffe7}50%{box-shadow:0 0 5px #00ffe7,0 0 10px #00ffe7}}
    .bar{display:flex;flex-wrap:wrap;justify-content:center;gap:8px}
    /* Debug badge */
    #debugBadge{position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);border:1px solid #00ffea;color:#00ffea;padding:8px 10px;border-radius:8px;font-size:0.85rem;z-index:9999;text-align:left;min-width:170px}
    #midnightToast{position:fixed;left:50%;transform:translateX(-50%);bottom:24px;background:#111;padding:12px 18px;border-radius:8px;border:1px solid #00ffe7;color:#ffcc00;z-index:9999;display:none}
    /* Active trade overlay panel (persistent) */
    #activeTradePanel{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.75);border:1px solid #00ffe7;color:#ffcc00;padding:12px;border-radius:8px;z-index:9998;min-width:260px;font-size:0.95rem}
    #activeTradePanel h4{margin:0 0 6px 0;color:#00ffe7}
    #activeTradePanel .small{font-size:0.85rem;color:#9ad}
    .btn-small{background:#000;border:1px solid #00ffea;color:#00ffea;padding:6px 8px;border-radius:6px;cursor:pointer;margin-left:6px}
    /* History list small */
    #historyList{max-height:200px;overflow:auto;margin-top:8px;text-align:left;font-size:0.85rem}
    .hist-item{border-bottom:1px dashed #223;padding:6px 0}
  </style>
</head>
<body>
  <canvas id="starfield"></canvas>
  <h1>üöÄ TS ANGEL FOREX AI (BTC ‚Ä¢ GOLD ‚Ä¢ USOIL)</h1>
  <p id="timeDisplay">‚è∞ CURRENT INDIAN TIME:</p>

  <div class="bar">
    <select id="pairSelect" title="PAIR">
      <option value="BTCUSD">BTCUSD</option>
      <option value="XAUUSD" selected>XAUUSD</option>
      <option value="USOIL">USOIL</option>
    </select>

    <select id="modeSelect" title="MODE">
      <option value="MANUAL" selected>MANUAL</option>
      <option value="AUTO">AUTO</option>
    </select>

    <button onclick="playClick(); generateSignal()">üì° GENERATE SIGNAL</button>
    <button onclick="playClick(); resetSignal()">‚ôªÔ∏è RESET</button>
  </div>

  <div class="signal-box" id="signalBox">üîç WAITING FOR SIGNAL...</div>
  <iframe id="tvChart"></iframe>
  <div class="watermark">üí° CREATED BY TRADER SUMON</div>
  <audio id="clickSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-click-1114.mp3"></audio>

  <!-- Debug badge, midnight toast, active trade panel -->
  <div id="debugBadge">LOADING STATS...</div>
  <div id="midnightToast"></div>
  <div id="activeTradePanel" style="display:none">
    <h4>ACTIVE TRADE</h4>
    <div id="activeTradeContent">No active trade</div>
    <div style="margin-top:8px">
      <button class="btn-small" onclick="focusOnActive()">SHOW</button>
      <button class="btn-small" onclick="closeActiveByUser()">CLOSE</button>
    </div>
    <div id="historyList"></div>
  </div>

<script>
/* ================= DOM ================= */
const pairSelect   = document.getElementById("pairSelect");
const modeSelect   = document.getElementById("modeSelect");
const tvChart      = document.getElementById("tvChart");
const signalBox    = document.getElementById("signalBox");
const timeDisplay  = document.getElementById("timeDisplay");
const clickSound   = document.getElementById("clickSound");
const debugBadge   = document.getElementById("debugBadge");
const midnightToast= document.getElementById("midnightToast");
const activeTradePanel = document.getElementById("activeTradePanel");
const activeTradeContent= document.getElementById("activeTradeContent");
const historyListEl = document.getElementById("historyList");

/* ================= STATE ================= */
let activeSignal   = null;
let pendingTimer   = null;
let autoMonitorId  = null;
let activeMonitorId = null; // for active trade monitoring

/* ================= PERSISTED KEYS ================= */
const STATS_KEY = "ts_angel_trade_stats_v1";
const SUMMARY_KEY = "ts_angel_daily_summaries_v1"; // last 7 days
const ACTIVE_KEY = "ts_angel_active_trade_v1";
const HISTORY_KEY = "ts_angel_trade_history_v1";

/* ================= PERSISTED STATS (daily/session counters) ================= */
function loadStats(){
  try{
    const raw = localStorage.getItem(STATS_KEY);
    if(!raw) return createEmptyStats();
    const obj = JSON.parse(raw);
    const today = getISTDateString(new Date());
    if(obj.date !== today) return createEmptyStats();
    return obj;
  }catch(e){ return createEmptyStats(); }
}
function createEmptyStats(){
  const today = getISTDateString(new Date());
  return { date: today, total: 0, perSession: { ASIA:0, LONDON:0, NEWYORK:0 }, perPair: {} };
}
function saveStats(s){ localStorage.setItem(STATS_KEY, JSON.stringify(s)); logStatsToConsole(); updateDebugBadge(); }
let tradeStats = loadStats();

/* ================= HISTORY & ACTIVE PERSISTENCE ================= */
function loadHistory(){ try{ const r = localStorage.getItem(HISTORY_KEY); return r ? JSON.parse(r) : []; }catch(e){ return []; } }
function saveHistory(arr){ try{ localStorage.setItem(HISTORY_KEY, JSON.stringify(arr.slice(0,50))); }catch(e){} }
function pushHistory(obj){
  const arr = loadHistory();
  arr.unshift(obj);
  saveHistory(arr);
  renderHistory();
}
function saveActiveSignal(sig){
  if(!sig){ localStorage.removeItem(ACTIVE_KEY); return; }
  try{ localStorage.setItem(ACTIVE_KEY, JSON.stringify(sig)); }catch(e){}
}
function loadActiveSignal(){ try{ const r = localStorage.getItem(ACTIVE_KEY); return r ? JSON.parse(r) : null; }catch(e){ return null; } }
function clearActiveSignal(){
  activeSignal = null;
  saveActiveSignal(null);
  activeTradePanel.style.display = "none";
  renderSignalUpper("üîÑ ACTIVE TRADE CLEARED");
}

/* ================= CONFIG =================
  Minimal changes as before; added min/max trades etc.
*/
const CONFIG = {
  XAUUSD: {
    tv: "OANDA:XAUUSD",
    fetch: async () => {
      const res = await fetch("https://api.twelvedata.com/price?symbol=XAU/USD&apikey=cd96961a49e242fe939a80866e70c57d");
      const data = await res.json();
      return parseFloat(data.price);
    },
    pivot: 3377.28,
    bias: 3350.50,
    tolerance: 0.5,
    zones: (price) => {
      const momentumSell = price < 3377.28;
      const levelsSell = [3372,3370,3365,3360,3356,3351];
      const levelsBuy  = [3381,3385,3389,3394];
      return momentumSell ? levelsSell : levelsBuy;
    },
    tps: {tp1:5,tp2:10,tp3:15},
    slGap:4,
    digits:2,
    minTradesPerDay: 1,
    maxTradesPerDay: 3,
    maxTradesPerSession: 1,
    earlyEntryPips: 7,
    earlyEntryPercent: 0.15
  },
  BTCUSD: {
    tv: "BINANCE:BTCUSDT",
    fetch: async () => {
      const res = await fetch("https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT");
      const data = await res.json();
      return parseFloat(data.price);
    },
    pivot: 65000,
    bias: 60000,
    tolerance: 20,
    zones: (price) => {
      const step = 50;
      const base = Math.round(price / step) * step;
      const momentumSell = price < 65000;
      const ups  = [base + step, base + 2*step, base + 3*step];
      const downs = [base - step, base - 2*step, base - 3*step, base - 4*step];
      return momentumSell ? downs : ups;
    },
    tps: {tp1:100,tp2:200,tp3:300},
    slGap:80,
    digits:2,
    minTradesPerDay: 1,
    maxTradesPerDay: 3,
    maxTradesPerSession: 1,
    earlyEntryPips: 150,
    earlyEntryPercent: 0.20
  },
  USOIL: {
    tv: "TVC:USOIL",
    fetch: async () => {
      try {
        const r1 = await fetch("https://api.twelvedata.com/price?symbol=WTICOUSD&apikey=cd96961a49e242fe939a80866e70c57d");
        const d1 = await r1.json();
        if (d1 && d1.price) return parseFloat(d1.price);
      } catch(e){}
      try {
        const r2 = await fetch("https://api.twelvedata.com/price?symbol=BRN/USD&apikey=cd96961a49e242fe939a80866e70c57d");
        const d2 = await r2.json();
        if (d2 && d2.price) return parseFloat(d2.price);
      } catch(e){}
      throw new Error("OIL price fetch failed");
    },
    pivot: 80,
    bias: 78,
    tolerance: 0.2,
    zones: (price) => {
      const step = 0.5;
      const base = Math.round(price / step) * step;
      const momentumSell = price < 80;
      const ups   = [base + step, base + 2*step, base + 3*step];
      const downs = [base - step, base - 2*step, base - 3*step, base - 4*step];
      return momentumSell ? downs : ups;
    },
    tps: {tp1:0.5,tp2:1.0,tp3:1.5},
    slGap:0.4,
    digits:2,
    minTradesPerDay: 1,
    maxTradesPerDay: 3,
    maxTradesPerSession: 1,
    earlyEntryPips: 0.5,
    earlyEntryPercent: 0.20
  }
};

/* ================= AUDIO/TTS ================= */
function speak(text){
  try{
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'bn-IN';
    const v = speechSynthesis.getVoices();
    const fv = v.find(x=>x.lang==='bn-IN' && x.name && x.name.toLowerCase().includes('female'));
    if(fv) u.voice = fv;
    speechSynthesis.speak(u);
  }catch(e){}
}
function playClick(){ try{ clickSound.play(); }catch(e){} }

/* ================= CHART LOAD ================= */
pairSelect.addEventListener("change", () => { loadChart(); renderSignalUpper("üîÑ PAIR CHANGED. WAITING FOR SIGNAL..."); });
function loadChart(){
  const pair = pairSelect.value;
  const tv = CONFIG[pair].tv;
  tvChart.src = `https://s.tradingview.com/widgetembed/?frameElementId=tvChart&symbol=${encodeURIComponent(tv)}&interval=5&theme=dark&style=1&timezone=Asia/Kolkata&withdateranges=1&studies=[]&toolbarbg=rgba(0,0,0,1)&hide_side_toolbar=0&allow_symbol_change=1&saveimage=1&details=1&hotlist=1&calendar=1&drawings_access=%7B%22type%22%3A%22black%22%7D`;
}
loadChart();

/* ================= HELPERS ================= */
function fmt(n,d=2){ return Number(n).toFixed(d) }
function renderSignalUpper(text){ signalBox.innerHTML = String(text).toUpperCase().replace(/\n/g,"<br>") }
function near(a,b,tol){ return Math.abs(a-b) <= tol }
function renderLevelsClickable(levels,digits=2){
  if(!levels||!levels.length) return "";
  return `<div class="levels">LEVELS: ${levels.map(l => `<a onclick="tapLevel(${l})">${fmt(l,digits)}</a>`).join(" ")}</div>`;
}
function getISTDateString(d){
  const utc = d.getTime() + (d.getTimezoneOffset() * 60000);
  const istOffset = 5.5 * 60 * 60 * 1000;
  const ist = new Date(utc + istOffset);
  return ist.toISOString().split('T')[0];
}
function getSessionName(date){
  const utc = date.getTime() + (date.getTimezoneOffset() * 60000);
  const istOffset = 5.5 * 60 * 60 * 1000;
  const ist = new Date(utc + istOffset);
  const h = ist.getHours();
  if(h >= 0 && h <= 8) return "ASIA";
  if(h >= 9 && h <= 16) return "LONDON";
  return "NEWYORK";
}

/* ================= DEBUG & MIDNIGHT SUMMARY HELPERS (ADDED) ================= */
function logStatsToConsole(){
  try{ console.log("[TS-ANGEL] tradeStats:", JSON.stringify(tradeStats)); }catch(e){}
}
function updateDebugBadge(){
  const s = tradeStats;
  const today = s.date || getISTDateString(new Date());
  const asia = s.perSession.ASIA||0, lon = s.perSession.LONDON||0, ny = s.perSession.NEWYORK||0;
  debugBadge.innerHTML = `DATE: ${today}<br>TOTAL: ${s.total}<br>ASIA:${asia} LONDON:${lon} NY:${ny}`;
}
function loadSummaries(){ try{ const raw = localStorage.getItem(SUMMARY_KEY); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
function saveSummaryObject(obj){
  const arr = loadSummaries();
  arr.unshift(obj);
  const trimmed = arr.slice(0,7);
  localStorage.setItem(SUMMARY_KEY, JSON.stringify(trimmed));
}
function showMidnightToast(text){
  midnightToast.innerHTML = text;
  midnightToast.style.display = "block";
  setTimeout(()=>{ midnightToast.style.display = "none"; }, 12_000);
}
function scheduleMidnightJob(){
  const now = new Date();
  const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
  const istOffset = 5.5 * 60 * 60 * 1000;
  const istNow = new Date(utc + istOffset);
  const nextMid = new Date(istNow);
  nextMid.setHours(24,0,5,0);
  const msUntil = nextMid.getTime() - istNow.getTime();
  setTimeout(()=>{ runMidnightSummary(); setInterval(runMidnightSummary, 24*60*60*1000); }, msUntil);
}
function runMidnightSummary(){
  try{
    const s = tradeStats;
    const summary = {
      date: s.date || getISTDateString(new Date(Date.now() + 5.5*3600000)),
      total: s.total || 0,
      perSession: s.perSession || {ASIA:0,LONDON:0,NEWYORK:0},
      perPair: s.perPair || {}
    };
    saveSummaryObject(summary);
    const msg = `MIDNIGHT SUMMARY ‚Äî ${summary.date}\nTOTAL: ${summary.total} | ASIA:${summary.perSession.ASIA||0} LONDON:${summary.perSession.LONDON||0} NEWYORK:${summary.perSession.NEWYORK||0}`;
    renderSignalUpper(msg);
    speak(`Aajker report. Total trades ${summary.total}. Asia ${summary.perSession.ASIA||0}, London ${summary.perSession.LONDON||0}, New York ${summary.perSession.NEWYORK||0}`);
    showMidnightToast(msg.replace(/\n/g,"<br>"));
    tradeStats = createEmptyStats();
    saveStats(tradeStats);
  }catch(e){ console.error("Midnight summary error",e); }
}

/* ================= HISTORY RENDER ================= */
function renderHistory(){
  const arr = loadHistory();
  historyListEl.innerHTML = arr.slice(0,20).map(h=>{
    return `<div class="hist-item"><strong>${h.pair}</strong> ${h.direction} ‚Äî ${h.result} ‚Äî ${h.time} <div class="small">${h.note||""}</div></div>`;
  }).join("") || "<div class='small'>No history yet</div>";
}

/* ================= MANUAL TAP ================= */
async function tapLevel(level){
  if(activeSignal){ renderSignalUpper("‚è≥ WAIT: A SIGNAL IS ALREADY ACTIVE!"); speak("Wait, a signal is already active"); return; }
  const pair = pairSelect.value;
  const cfg  = CONFIG[pair];
  const session = getSessionName(new Date());
  if(tradeStats.perSession[session] >= cfg.maxTradesPerSession){
    renderSignalUpper(`üö´ SESSION LIMIT REACHED FOR ${session}.`); speak("Session limit reached");
    return;
  }
  if(tradeStats.total >= cfg.maxTradesPerDay){
    renderSignalUpper("üö´ DAILY MAX TRADES REACHED."); speak("Daily maximum trades reached");
    return;
  }

  let price;
  try{ price = await cfg.fetch(); } catch(e){ renderSignalUpper("‚ùå ERROR FETCHING LIVE PRICE!"); return; }
  const direction = (price < cfg.pivot) ? "SELL" : "BUY";
  const entry = fmt(level,cfg.digits);
  const tp1 = direction==="BUY" ? fmt(level+cfg.tps.tp1,cfg.digits) : fmt(level-cfg.tps.tp1,cfg.digits);
  const tp2 = direction==="BUY" ? fmt(level+cfg.tps.tp2,cfg.digits) : fmt(level-cfg.tps.tp2,cfg.digits);
  const tp3 = direction==="BUY" ? fmt(level+cfg.tps.tp3,cfg.digits) : fmt(level-cfg.tps.tp3,cfg.digits);
  const sl  = direction==="BUY" ? fmt(level-cfg.slGap,cfg.digits) : fmt(level+cfg.slGap,cfg.digits);
  const time= new Date().toLocaleTimeString("en-IN",{hour12:true});
  activeSignal = {pair,direction,entry,tp1,tp2,tp3,sl,time,mode:"MANUAL-TAP",status:"RUNNING",hits:{tp1:false,tp2:false,tp3:false,sl:false}};
  // update counters
  tradeStats.total += 1;
  tradeStats.perSession[session] = (tradeStats.perSession[session]||0)+1;
  tradeStats.perPair[pair] = (tradeStats.perPair[pair]||0)+1;
  saveStats(tradeStats); // persist
  saveActiveSignal(activeSignal);
  showActivePanel();
  const txt =
`üìä ${pair}: ${direction}
‚öôÔ∏è MODE: MANUAL-TAP
üü° ENTRY: ${entry}
üéØ TP1: ${tp1} | TP2: ${tp2} | TP3: ${tp3}
üõë SL: ${sl}
üìç LIVE PRICE: ${fmt(price,cfg.digits)}
üìà TRADE IS LIVE...`;
  renderSignalUpper(txt);
  speak(`${pair} ${direction}. Entry ${entry}. TP1 ${tp1}, TP2 ${tp2}, SL ${sl}`);
  startActiveMonitor(); // start monitoring active trade
}

/* ================= FETCH LIVE PRICE (wrapper) ================= */
async function fetchLivePrice(pair){
  try{ return await CONFIG[pair].fetch(); } catch(e){ renderSignalUpper("‚ùå ERROR FETCHING LIVE PRICE!"); console.error(e); return null; }
}

/* ================= GET SETUP (gold-style) ================= */
function getSetup(pair,price){
  const cfg = CONFIG[pair];
  const momentumSell = price < cfg.pivot;
  const direction = momentumSell ? "SELL" : "BUY";
  const entryZones = cfg.zones(price);
  const inZone = entryZones.some(l => near(price, l, cfg.tolerance));
  const nearest = entryZones.slice().sort((a,b)=>Math.abs(price-a)-Math.abs(price-b))[0];
  const entry = fmt(nearest??price,cfg.digits);
  const tp1 = direction==="BUY" ? fmt(Number(entry)+cfg.tps.tp1,cfg.digits) : fmt(Number(entry)-cfg.tps.tp1,cfg.digits);
  const tp2 = direction==="BUY" ? fmt(Number(entry)+cfg.tps.tp2,cfg.digits) : fmt(Number(entry)-cfg.tps.tp2,cfg.digits);
  const tp3 = direction==="BUY" ? fmt(Number(entry)+cfg.tps.tp3,cfg.digits) : fmt(Number(entry)-cfg.tps.tp3,cfg.digits);
  const sl  = direction==="BUY" ? fmt(Number(entry)-cfg.slGap,cfg.digits) : fmt(Number(entry)+cfg.slGap,cfg.digits);
  return {direction,entryZones,inZone,entry,tp1,tp2,tp3,sl,nearest};
}

/* ================= MANUAL GENERATE BUTTON (keeps same logic) ================= */
async function generateSignal(){
  const now = new Date();
  const pair = pairSelect.value;
  const day  = now.getDay();
  const time = now.toLocaleTimeString("en-IN",{hour12:true});
  if((pair==="XAUUSD") && (day===6||day===0)){ renderSignalUpper("‚ö†Ô∏è GOLD MARKET IS CLOSED TODAY."); speak("Gold market is closed today"); return; }
  if(activeSignal){ renderSignalUpper("‚è≥ WAIT: A SIGNAL IS ALREADY ACTIVE!"); speak("Wait, a signal is already active"); return; }
  if(tradeStats.date !== getISTDateString(new Date())) {
    tradeStats = createEmptyStats();
    saveStats(tradeStats);
  }
  const session = getSessionName(new Date());
  const cfg = CONFIG[pair];
  if(tradeStats.perSession[session] >= cfg.maxTradesPerSession){
    renderSignalUpper(`üö´ SESSION LIMIT REACHED FOR ${session}.`);
    speak("Session limit reached");
    return;
  }
  if(tradeStats.total >= cfg.maxTradesPerDay){
    renderSignalUpper("üö´ DAILY MAX TRADES REACHED.");
    speak("Daily maximum trades reached");
    return;
  }
  const price = await fetchLivePrice(pair);
  if(!price) return;
  const s = getSetup(pair,price);
  if(s.inZone){
    executeAndRecordAutoOrManual(pair, s, price, "INTRADAY");
    return;
  }
  let allowEarly = false;
  let earlyReason = "";
  const nearest = s.nearest ?? price;
  const diff = Math.abs(price - nearest);
  if(cfg.earlyEntryPips && diff <= cfg.earlyEntryPips){
    allowEarly = true;
    earlyReason = `PRICE ${fmt(diff,cfg.digits)} AWAY (PIPS TOLERANCE)`;
  } else if(cfg.earlyEntryPercent){
    const pct = (diff/price)*100;
    if(pct <= cfg.earlyEntryPercent){
      allowEarly = true;
      earlyReason = `PRICE ${fmt(pct,3)}% AWAY (PCT TOLERANCE)`;
    }
  }
  if(!allowEarly && tradeStats.total < cfg.minTradesPerDay){
    const extendedTol = (cfg.earlyEntryPips || (price*cfg.earlyEntryPercent/100)) * 2;
    const diff2 = Math.abs(price - nearest);
    if(diff2 <= extendedTol){
      allowEarly = true;
      earlyReason = `FALLBACK MIN-TRADE MODE ‚Äî EXTENDED TOLERANCE ${fmt(extendedTol,cfg.digits)}`;
    }
  }
  if(!allowEarly){
    const msg =
`‚ùå NO VALID TRADE SETUP NOW.
PRICE NOT NEAR ANY KEY ZONE.
CURRENT: ${fmt(price, CONFIG[pair].digits)}
${renderLevelsClickable(s.entryZones, CONFIG[pair].digits)}`;
    signalBox.innerHTML = msg.toUpperCase().replace(/\n/g,"<br>");
    speak("No trade now. Price not near level zone.");
    return;
  }
  const earlyEntryObj = Object.assign({}, s);
  earlyEntryObj.entry = fmt(s.nearest ?? price, cfg.digits);
  executeAndRecordAutoOrManual(pair, earlyEntryObj, price, "EARLY (REDUCED RISK)", earlyReason);
}

/* ================= EXECUTION & RECORDING (shared) ================= */
function executeAndRecordAutoOrManual(pair, setupObj, livePrice, mode="AUTO", extraNote=""){
  if(activeSignal) return;
  const cfg = CONFIG[pair];
  const session = getSessionName(new Date());
  if(tradeStats.perSession[session] >= cfg.maxTradesPerSession) {
    renderSignalUpper(`üö´ SESSION LIMIT REACHED FOR ${session}.`);
    speak("Session limit reached");
    return;
  }
  if(tradeStats.total >= cfg.maxTradesPerDay) {
    renderSignalUpper("üö´ DAILY MAX TRADES REACHED.");
    speak("Daily maximum trades reached");
    return;
  }
  const time = new Date().toLocaleTimeString("en-IN",{hour12:true});
  activeSignal = {
    pair,
    direction: setupObj.direction,
    entry: setupObj.entry,
    tp1: setupObj.tp1,
    tp2: setupObj.tp2,
    tp3: setupObj.tp3,
    sl: setupObj.sl,
    time,
    mode,
    status: "RUNNING",
    note: extraNote,
    hits: {tp1:false,tp2:false,tp3:false,sl:false}
  };
  tradeStats.total += 1;
  tradeStats.perSession[session] = (tradeStats.perSession[session]||0)+1;
  tradeStats.perPair[pair] = (tradeStats.perPair[pair]||0)+1;
  saveStats(tradeStats);
  saveActiveSignal(activeSignal);
  const noteLine = extraNote ? `\nNOTE: ${extraNote}` : "";
  const execText = `üìä ${pair}: ${setupObj.direction}
‚öôÔ∏è MODE: ${mode}
üü° ENTRY: ${setupObj.entry}
üéØ TP1: ${setupObj.tp1} | TP2: ${setupObj.tp2} | TP3: ${setupObj.tp3}
üõë SL: ${setupObj.sl}
üìç LIVE PRICE: ${fmt(livePrice, CONFIG[pair].digits)}
üìà TRADE IS LIVE...${noteLine}`;
  renderSignalUpper(execText);
  speak(`${pair} ${setupObj.direction}. Entry ${activeSignal.entry}. TP1 ${activeSignal.tp1}, SL ${activeSignal.sl}`);
  showActivePanel();
  startActiveMonitor();
}

/* ================= ACTIVE TRADE MONITOR (checks TP/SL hits) ================= */
const ACTIVE_CHECK_MS = 60_000;
async function startActiveMonitor(){
  if(activeMonitorId) return;
  await checkActiveTrade(); // immediate
  activeMonitorId = setInterval(checkActiveTrade, ACTIVE_CHECK_MS);
}
function stopActiveMonitor(){
  if(activeMonitorId){ clearInterval(activeMonitorId); activeMonitorId = null; }
}
async function checkActiveTrade(){
  if(!activeSignal) { stopActiveMonitor(); return; }
  const pair = activeSignal.pair;
  const cfg = CONFIG[pair];
  let price;
  try{ price = await fetchLivePrice(pair); } catch(e){ return; }
  if(price===null) return;
  const numPrice = Number(price);
  const nums = {
    entry: Number(activeSignal.entry),
    tp1: Number(activeSignal.tp1),
    tp2: Number(activeSignal.tp2),
    tp3: Number(activeSignal.tp3),
    sl: Number(activeSignal.sl)
  };
  const dir = activeSignal.direction;
  // check hits
  if(dir === "BUY"){
    if(!activeSignal.hits.tp1 && numPrice >= nums.tp1){
      activeSignal.hits.tp1 = true; onLevelHit("TP1", nums.tp1, numPrice); return;
    }
    if(!activeSignal.hits.tp2 && numPrice >= nums.tp2){
      activeSignal.hits.tp2 = true; onLevelHit("TP2", nums.tp2, numPrice); return;
    }
    if(!activeSignal.hits.tp3 && numPrice >= nums.tp3){
      activeSignal.hits.tp3 = true; onLevelHit("TP3", nums.tp3, numPrice); return;
    }
    if(!activeSignal.hits.sl && numPrice <= nums.sl){
      activeSignal.hits.sl = true; onLevelHit("SL", nums.sl, numPrice); return;
    }
  } else {
    if(!activeSignal.hits.tp1 && numPrice <= nums.tp1){
      activeSignal.hits.tp1 = true; onLevelHit("TP1", nums.tp1, numPrice); return;
    }
    if(!activeSignal.hits.tp2 && numPrice <= nums.tp2){
      activeSignal.hits.tp2 = true; onLevelHit("TP2", nums.tp2, numPrice); return;
    }
    if(!activeSignal.hits.tp3 && numPrice <= nums.tp3){
      activeSignal.hits.tp3 = true; onLevelHit("TP3", nums.tp3, numPrice); return;
    }
    if(!activeSignal.hits.sl && numPrice >= nums.sl){
      activeSignal.hits.sl = true; onLevelHit("SL", nums.sl, numPrice); return;
    }
  }
  // update panel price
  updateActivePanelPrice(numPrice);
  saveActiveSignal(activeSignal);
}

/* ================= ON LEVEL HIT HANDLER ================= */
function onLevelHit(levelName, levelValue, livePrice){
  const time = new Date().toLocaleTimeString("en-IN",{hour12:true});
  const pair = activeSignal.pair;
  const direction = activeSignal.direction;
  const msg = `${pair} ${levelName} HIT ‚Äî LEVEL: ${fmt(levelValue, CONFIG[pair].digits)} | PRICE: ${fmt(livePrice, CONFIG[pair].digits)} | TIME: ${time}`;
  renderSignalUpper(`‚úÖ ${msg}`);
  speak(`${pair} ${levelName} hit`);
  pushHistory({pair, direction, result:`${levelName} HIT`, time, note: `price:${fmt(livePrice, CONFIG[pair].digits)}`});
  saveActiveSignal(activeSignal);
  // if SL or TP3 -> finalize
  if(levelName === "SL"){
    finalizeActiveTrade("LOSS", levelName);
  } else if(levelName === "TP3"){
    finalizeActiveTrade("PROFIT - TP3", levelName);
  } else {
    // keep active for next hits
    showActivePanel();
  }
}

/* ================= FINALIZE TRADE ================= */
function finalizeActiveTrade(resultText, levelName){
  if(!activeSignal) return;
  activeSignal.status = "CLOSED";
  activeSignal.closedAt = new Date().toLocaleTimeString("en-IN",{hour12:true});
  activeSignal.result = resultText;
  saveActiveSignal(activeSignal);
  pushHistory({
    pair: activeSignal.pair,
    direction: activeSignal.direction,
    result: resultText,
    time: activeSignal.closedAt,
    note: `closed by ${levelName}`
  });
  const finalMsg = `TRADE CLOSED: ${activeSignal.pair} ‚Äî ${resultText} ‚Äî CLOSED AT ${activeSignal.closedAt}`;
  renderSignalUpper(finalMsg);
  speak(finalMsg);
  showActivePanel();
  stopActiveMonitor();
  // leave panel visible until user clears or reset
}

/* ================= UTILS FOR ACTIVE PANEL ================= */
function showActivePanel(){
  if(!activeSignal){ activeTradePanel.style.display = "none"; return; }
  activeTradePanel.style.display = "block";
  const s = activeSignal;
  const lines = `
PAIR: ${s.pair} <br>
DIR: ${s.direction} <br>
ENTRY: ${s.entry} <br>
TP1: ${s.tp1} | TP2: ${s.tp2} | TP3: ${s.tp3} <br>
SL: ${s.sl} <br>
MODE: ${s.mode} <br>
STATUS: ${s.status} ${s.result ? " | " + s.result : ""} <br>
HITS: TP1:${s.hits.tp1?1:0} TP2:${s.hits.tp2?1:0} TP3:${s.hits.tp3?1:0} SL:${s.hits.sl?1:0} <br>
TIME: ${s.time} <br>
NOTE: ${s.note||""}
`;
  activeTradeContent.innerHTML = lines;
  renderHistory();
}
function updateActivePanelPrice(price){
  if(!activeSignal) return;
  // append a short live price line (keeps panel concise)
  const liveLine = `<div class="small">LIVE: ${fmt(price, CONFIG[activeSignal.pair].digits)}</div>`;
  // ensure we don't grow infinitely: replace last live if exists
  if(activeTradeContent.innerHTML.includes("LIVE:")){
    activeTradeContent.innerHTML = activeTradeContent.innerHTML.replace(/<div class="small">LIVE:[\s\S]*?<\/div>$/,"") + liveLine;
  } else {
    activeTradeContent.innerHTML = activeTradeContent.innerHTML + liveLine;
  }
}

/* ================= MANUAL CLOSE/USER ACTIONS ================= */
function closeActiveByUser(){
  if(!activeSignal) return;
  finalizeActiveTrade("CLOSED BY USER", "USER");
  setTimeout(()=>{ clearActiveSignal(); renderHistory(); }, 3000);
}
function focusOnActive(){
  if(!activeSignal) { renderSignalUpper("No active trade"); return;}
  renderSignalUpper(`ACTIVE: ${activeSignal.pair} ${activeSignal.direction} ENTRY ${activeSignal.entry} TP1 ${activeSignal.tp1} SL ${activeSignal.sl}`);
}

/* ================= AUTO MONITOR (1MIN) + 10MIN CONFIRM (unchanged core) ================= */
const MONITOR_EVERY_MS = 60_000;
const AUTO_DELAY_MS = 10 * 60_000;

async function autoMonitorTick(){
  if(activeSignal) return;
  const pair = pairSelect.value;
  const day = new Date().getDay();
  if((pair==="XAUUSD") && (day===6||day===0)){ renderSignalUpper("‚ö†Ô∏è GOLD MARKET IS CLOSED TODAY."); return; }
  if(tradeStats.date !== getISTDateString(new Date())){ tradeStats = createEmptyStats(); saveStats(tradeStats); }
  const cfg = CONFIG[pair];
  const session = getSessionName(new Date());
  if(tradeStats.perSession[session] >= cfg.maxTradesPerSession) { updateDebugBadge(); return; }
  if(tradeStats.total >= cfg.maxTradesPerDay) { updateDebugBadge(); return; }
  let price = null;
  try{ price = await fetchLivePrice(pair); } catch(e){}
  if(!price) return;
  const s = getSetup(pair,price);
  const baseHeader = `üõ∞Ô∏è AUTO MONITORING ACTIVE ‚Äî PAIR: ${pair} ‚Äî PRICE: ${fmt(price, CONFIG[pair].digits)}`;
  if(!s.inZone){
    const view = `${baseHeader}
NO VALID SETUP NEAR ZONES.
${renderLevelsClickable(s.entryZones, CONFIG[pair].digits)}`;
    signalBox.innerHTML = view.toUpperCase().replace(/\n/g,"<br>");
    updateDebugBadge();
    return;
  }
  const nowStr = new Date().toLocaleTimeString("en-IN",{hour12:true});
  const pendingText = `${baseHeader}
FOUND SETUP NEAR LEVEL ‚Äî MARKED AS PENDING
DIRECTION: ${s.direction}
PLANNED ENTRY: ${s.entry}
SL: ${s.sl} | TP1: ${s.tp1} | TP2: ${s.tp2} | TP3: ${s.tp3}
WILL AUTO-EXECUTE IN 10 MINUTES IF STILL VALID
DETECTED AT: ${nowStr}`;
  renderSignalUpper(pendingText);
  speak("Potential setup found. Will execute in ten minutes if still valid.");
  if(pendingTimer){ clearTimeout(pendingTimer); pendingTimer = null; }
  pendingTimer = setTimeout(async ()=>{
    if(activeSignal) return;
    if(tradeStats.perSession[session] >= cfg.maxTradesPerSession) { pendingTimer = null; updateDebugBadge(); return; }
    if(tradeStats.total >= cfg.maxTradesPerDay) { pendingTimer = null; updateDebugBadge(); return; }
    let rePrice = null;
    try{ rePrice = await fetchLivePrice(pair); } catch(e){}
    if(!rePrice) return;
    const re = getSetup(pair,rePrice);
    if(re.inZone){
      executeAndRecordAutoOrManual(pair, re, rePrice, "AUTO");
    } else {
      const nearest = re.nearest ?? rePrice;
      const diff = Math.abs(rePrice - nearest);
      let allowEarly = false;
      let earlyReason = "";
      if(cfg.earlyEntryPips && diff <= cfg.earlyEntryPips){
        allowEarly = true; earlyReason = `PRICE ${fmt(diff,cfg.digits)} AWAY (PIPS TOLERANCE)`;
      } else if(cfg.earlyEntryPercent){
        const pct = (diff/rePrice)*100;
        if(pct <= cfg.earlyEntryPercent){
          allowEarly = true; earlyReason = `PRICE ${fmt(pct,3)}% AWAY (PCT TOLERANCE)`;
        }
      }
      if(!allowEarly && tradeStats.total < cfg.minTradesPerDay){
        const extendedTol = (cfg.earlyEntryPips || (rePrice*cfg.earlyEntryPercent/100)) * 2;
        const diff2 = Math.abs(rePrice - nearest);
        if(diff2 <= extendedTol){
          allowEarly = true; earlyReason = `FALLBACK MIN-TRADE MODE ‚Äî EXTENDED TOLERANCE ${fmt(extendedTol,cfg.digits)}`;
        }
      }
      if(allowEarly){
        executeAndRecordAutoOrManual(pair, re, rePrice, "AUTO-EARLY", earlyReason);
      } else {
        const cancelText = `${baseHeader}
SETUP INVALID AFTER 10 MINUTES ‚Äî AUTO EXECUTION CANCELLED
${renderLevelsClickable(re.entryZones, CONFIG[pair].digits)}`;
        signalBox.innerHTML = cancelText.toUpperCase().replace(/\n/g,"<br>");
        speak("Setup cancelled after recheck.");
      }
    }
    pendingTimer = null;
    updateDebugBadge();
  }, AUTO_DELAY_MS);
  updateDebugBadge();
}

/* ================= MODE SWITCH ================= */
modeSelect.addEventListener("change", handleModeChange);
function handleModeChange(){
  const mode = modeSelect.value;
  if(pendingTimer){ clearTimeout(pendingTimer); pendingTimer = null; }
  if(autoMonitorId){ clearInterval(autoMonitorId); autoMonitorId = null; }
  if(mode === "AUTO"){
    renderSignalUpper("üõ∞Ô∏è AUTO MODE ON ‚Äî MONITORING LIVE PRICE...");
    autoMonitorId = setInterval(autoMonitorTick, MONITOR_EVERY_MS);
    autoMonitorTick();
  } else {
    renderSignalUpper("üñêÔ∏è MANUAL MODE ‚Äî TAP A LEVEL OR PRESS GENERATE SIGNAL");
  }
}
handleModeChange();

/* ================= RESET ================= */
function resetSignal(){
  if(pendingTimer){ clearTimeout(pendingTimer); pendingTimer = null; }
  activeSignal = null;
  saveActiveSignal(null);
  renderSignalUpper("üîÑ RESET DONE. WAITING FOR SIGNAL...");
  speak("Reset done");
  updateDebugBadge();
  showActivePanel();
  stopActiveMonitor();
}

/* ================= STARFIELD ================= */
const canvas = document.getElementById("starfield");
const ctx = canvas.getContext("2d");
let stars = [];
function resizeCanvas(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resizeCanvas();
for(let i=0;i<200;i++){ stars.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,size:Math.random()*2,speed:Math.random()*1}) }
function animateStars(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#00ffe7";
  stars.forEach(star=>{
    star.y += star.speed;
    if(star.y>canvas.height) star.y = 0;
    ctx.beginPath();
    ctx.arc(star.x,star.y,star.size,0,2*Math.PI);
    ctx.fill();
  });
  requestAnimationFrame(animateStars);
}
animateStars();

/* ================= CLOCK & INIT ================= */
setInterval(()=>{
  const now = new Date();
  timeDisplay.innerText = ("‚è∞ CURRENT INDIAN TIME: " + now.toLocaleTimeString("en-IN")).toUpperCase();
},1000);

// initial badge render & console log & history render
updateDebugBadge();
logStatsToConsole();
renderHistory();
// load persisted active signal if any
(function hydrateActive(){
  const a = loadActiveSignal();
  if(a){
    activeSignal = a;
    showActivePanel();
    if(activeSignal.status === "RUNNING"){
      startActiveMonitor();
    }
  }
})();
// schedule midnight job
scheduleMidnightJob();

</script>
</body>
</html>
