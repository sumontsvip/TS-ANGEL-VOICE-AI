<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TS Angel Forex AI (TEST)  </title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: 'Arial', sans-serif;
      color: white;
      background: black;
    }
    canvas#starfield {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    body { text-align: center; padding: 20px; }
    h1 { color: #00ffe7; animation: neon-flicker 1.5s infinite; }
    #timeDisplay {
      font-size: 1.2rem; color: #ffcc00; animation: neon-flicker 2s infinite;
    }
    select, button {
      padding: 12px 20px; margin: 10px; font-size: 1rem;
      border-radius: 5px; background-color: #111; color: #00ffea;
      border: 2px solid #00ffea; cursor: pointer; animation: glow-pulse 2s infinite;
    }
    button:hover { background-color: #00ffea; color: black; }
    iframe {
      width: 100%; height: 500px; border: none; margin-top: 25px; border-radius: 10px;
      box-shadow: 0 0 20px #00ffe7; animation: glow-pulse 3s infinite;
    }
    .signal-box {
      margin-top: 25px; background: #111; padding: 20px; border-radius: 10px;
      font-size: 1.1rem; color: #ffcc00; animation: glow-pulse 1.5s infinite;
    }
    .watermark { margin-top: 40px; font-size: 1.2rem; color: #00ffe7; animation: neon-flicker 2s infinite; }
    @keyframes neon-flicker {
      0%, 100% { text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff; }
      50%      { text-shadow: 0 0 2px #0ff, 0 0 5px #0ff; }
    }
    @keyframes glow-pulse {
      0%, 100% { box-shadow: 0 0 10px #00ffe7, 0 0 20px #00ffe7; }
      50%      { box-shadow: 0 0 5px #00ffe7, 0 0 10px #00ffe7; }
    }
    .toolbar { margin-top: 10px; }
  </style>
</head>
<body>
<canvas id="starfield"></canvas>

<h1>üöÄ TS Angel Forex AI (BTC ‚Ä¢ GOLD ‚Ä¢ US OIL)</h1>
<p id="timeDisplay">‚è∞ Current Indian Time: </p>

<div class="toolbar">
  <select id="pairSelect">
    <option value="BTCUSD">BTCUSD</option>
    <option value="XAUUSD">XAUUSD</option>
    <option value="USOIL">USOIL (WTI)</option>
  </select>

  <select id="modeSelect" title="Manual / Auto">
    <option value="MANUAL">MANUAL</option>
    <option value="AUTO">AUTO</option>
  </select>

  <button onclick="playClick(); generateSignal()">üì° Generate Signal</button>
  <button onclick="playClick(); resetSignal()">‚ôªÔ∏è Reset</button>
</div>

<div class="signal-box" id="signalBox">üîç Waiting for signal...</div>
<iframe id="tvChart"></iframe>
<div class="watermark">üí° Created by Trader Sumon</div>
<audio id="clickSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-click-1114.mp3"></audio>

<script>
/* ==== Elements ==== */
const pairSelect   = document.getElementById("pairSelect");
const tvChart      = document.getElementById("tvChart");
const signalBox    = document.getElementById("signalBox");
const timeDisplay  = document.getElementById("timeDisplay");
const clickSound   = document.getElementById("clickSound");
const modeSelect   = document.getElementById("modeSelect");

let activeSignal   = null;
let pendingTimer   = null;
let autoMonitorId  = null;

const MONITOR_EVERY_MS = 60_000; // 1 minute
const AUTO_DELAY_MS    = 10 * 60_000; // 10 minutes

/* ==== API KEYS (EDIT THESE) ==== */
const GOLD_API_KEY = "cd96961a49e242fe939a80866e70c57d"; // already in your code
const OIL_API_KEY  = "PUT_YOUR_TWELVEDATA_KEY_HERE";      // <-- add your key

/* ==== Voice ==== */
function speak(text) {
  try {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'bn-IN';
    const voices = speechSynthesis.getVoices();
    const femaleVoice = voices.find(v => v.lang === 'bn-IN' && v.name?.toLowerCase().includes("female"));
    if (femaleVoice) utterance.voice = femaleVoice;
    speechSynthesis.speak(utterance);
  } catch {}
}
function playClick() { try { clickSound.play(); } catch {} }

/* ==== TradingView Chart ==== */
pairSelect.addEventListener("change", loadChart);
function loadChart() {
  const symbol   = pairSelect.value;
  let tvSymbol;
  if (symbol === "BTCUSD") tvSymbol = "BINANCE:BTCUSDT";
  else if (symbol === "XAUUSD") tvSymbol = "OANDA:XAUUSD";
  else tvSymbol = "TVC:USOIL"; // WTI Crude on TradingView

  tvChart.src = `https://s.tradingview.com/widgetembed/?frameElementId=tvChart&symbol=${tvSymbol}&interval=5&theme=dark&style=1&timezone=Asia/Kolkata&withdateranges=1&studies=[]&toolbarbg=rgba(0,0,0,1)&hide_side_toolbar=0&allow_symbol_change=1&saveimage=1&details=1&hotlist=1&calendar=1&drawings_access=%7B%22type%22%3A%22black%22%7D`;
}
loadChart();

/* ==== Helpers ==== */
function isWeekendClosed(pair) {
  // Simple weekend close for GOLD & OIL (Sat=6, Sun=0)
  const day = new Date().getDay();
  if ((pair === "XAUUSD" || pair === "USOIL") && (day === 6 || day === 0)) return true;
  return false;
}

function renderSignalUpper(text) {
  signalBox.innerHTML = text.toUpperCase().replace(/\n/g, "<br>");
}
function renderLevelsClickable(levels=[]) {
  if (!levels.length) return "";
  return `<div class="levels"><span class="muted">TAP LEVEL TO EXECUTE:</span><br>${
    levels.map(l => `<span data-lvl="${l}" title="Tap to execute at level" style="cursor:pointer;padding:4px 8px;border:1px solid #00ffea;border-radius:6px;margin:4px;display:inline-block;">${l}</span>`).join(" ")
  }</div>`;
}
signalBox.addEventListener("click", (e) => {
  const span = e.target.closest("span[data-lvl]");
  if (!span) return;
  const lvl = parseFloat(span.getAttribute("data-lvl"));
  tapExecuteAtLevel(lvl);
});

/* ==== Live Price ==== */
async function fetchLivePrice(pair) {
  try {
    if (pair === "BTCUSD") {
      const res  = await fetch("https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT");
      const data = await res.json();
      return parseFloat(data.price);
    }
    if (pair === "XAUUSD") {
      const res  = await fetch(`https://api.twelvedata.com/price?symbol=XAU/USD&apikey=${GOLD_API_KEY}`);
      const data = await res.json();
      if (data && data.price) return parseFloat(data.price);
      throw new Error("Gold price not available");
    }
    if (pair === "USOIL") {
      // Try TwelveData: CL (Crude Oil Futures)
      let res  = await fetch(`https://api.twelvedata.com/price?symbol=CL&apikey=${OIL_API_KEY}`);
      let data = await res.json();
      if (data && data.price) return parseFloat(data.price);

      // Fallback: WTI/USD pair (if provider supports)
      res  = await fetch(`https://api.twelvedata.com/price?symbol=WTI/USD&apikey=${OIL_API_KEY}`);
      data = await res.json();
      if (data && data.price) return parseFloat(data.price);

      throw new Error("USOIL price not available (check API key/symbol)");
    }
  } catch (error) {
    signalBox.innerHTML = "‚ùå ERROR FETCHING LIVE PRICE!";
    console.error(error);
    return null;
  }
}

/* ==== GOLD Logic (original style) ==== */
function getGoldSetup(price) {
  const dailyBias    = price > 3350.5 ? "BUY" : "SELL";
  const momentumSell = price < 3377.28;
  const momentumBuy  = price > 3377.28;

  const sellZones = [3372, 3370, 3365, 3360, 3356, 3351];
  const buyZones  = [3381, 3385, 3389, 3394];

  const entryZones = momentumSell ? sellZones : buyZones;
  const direction  = momentumSell ? "SELL" : "BUY";
  const inZone     = entryZones.some(level => Math.abs(price - level) <= 0.5);

  const entry = parseFloat(price.toFixed(2));
  const tp1   = direction === "BUY" ? (entry + 5).toFixed(2)  : (entry - 5).toFixed(2);
  const tp2   = direction === "BUY" ? (entry + 10).toFixed(2) : (entry - 10).toFixed(2);
  const tp3   = direction === "BUY" ? (entry + 15).toFixed(2) : (entry - 15).toFixed(2);
  const sl    = direction === "BUY" ? (entry - 4).toFixed(2)  : (entry + 4).toFixed(2);

  return { dailyBias, momentumBuy, momentumSell, entryZones, inZone, direction, entry, tp1, tp2, tp3, sl };
}

/* ==== US OIL Logic (same style) ==== */
/* NOTE: Levels are placeholders; edit to your preferred zones */
function getOilSetup(price) {
  // Simple pivot for bias (adjust as you like)
  const pivot        = 80.00;
  const momentumSell = price < 81.50;
  const momentumBuy  = price > 81.50;

  const sellZones = [81.2, 81.0, 80.6, 80.2, 79.9, 79.5];
  const buyZones  = [81.8, 82.2, 82.6, 83.0];

  const entryZones = momentumSell ? sellZones : buyZones;
  const direction  = momentumSell ? "SELL" : "BUY";
  const inZone     = entryZones.some(level => Math.abs(price - level) <= 0.12); // tighter zone for oil

  const entry = parseFloat(price.toFixed(2));
  const tp1   = direction === "BUY" ? (entry + 0.30).toFixed(2) : (entry - 0.30).toFixed(2);
  const tp2   = direction === "BUY" ? (entry + 0.60).toFixed(2) : (entry - 0.60).toFixed(2);
  const tp3   = direction === "BUY" ? (entry + 0.90).toFixed(2) : (entry - 0.90).toFixed(2);
  const sl    = direction === "BUY" ? (entry - 0.25).toFixed(2) : (entry + 0.25).toFixed(2);

  const dailyBias = price > pivot ? "BUY" : "SELL";
  return { dailyBias, momentumBuy, momentumSell, entryZones, inZone, direction, entry, tp1, tp2, tp3, sl };
}

/* ==== BTC Logic (simple) ==== */
function getBTCSetup(price) {
  // Example zones; adjust freely
  const pivot        = 65000;
  const momentumSell = price < 65200;
  const momentumBuy  = price > 65200;

  const sellZones = [65100, 64950, 64800, 64650];
  const buyZones  = [65300, 65500, 65750, 66000];

  const entryZones = momentumSell ? sellZones : buyZones;
  const direction  = momentumSell ? "SELL" : "BUY";
  const inZone     = entryZones.some(level => Math.abs(price - level) <= 25);

  const entry = parseFloat(price.toFixed(2));
  const tp1   = direction === "BUY" ? (entry + 80).toFixed(2)  : (entry - 80).toFixed(2);
  const tp2   = direction === "BUY" ? (entry + 160).toFixed(2) : (entry - 160).toFixed(2);
  const tp3   = direction === "BUY" ? (entry + 240).toFixed(2) : (entry - 240).toFixed(2);
  const sl    = direction === "BUY" ? (entry - 60).toFixed(2)  : (entry + 60).toFixed(2);

  const dailyBias = price > pivot ? "BUY" : "SELL";
  return { dailyBias, momentumBuy, momentumSell, entryZones, inZone, direction, entry, tp1, tp2, tp3, sl };
}

/* ==== Get Setup Switch ==== */
function getSetup(pair, price) {
  if (pair === "XAUUSD") return getGoldSetup(price);
  if (pair === "USOIL")  return getOilSetup(price);
  return getBTCSetup(price);
}

/* ==== Manual Tap Execute ==== */
async function tapExecuteAtLevel(level) {
  const pair  = pairSelect.value;
  const price = await fetchLivePrice(pair);
  if (price == null) return;
  const time  = new Date().toLocaleTimeString("en-IN", { hour12: true });

  const direction = price <= level ? "BUY" : "SELL";
  const entry = level.toFixed(2);

  // TPs/SL per-asset scaling
  let tp1, tp2, tp3, sl;
  if (pair === "XAUUSD") {
    tp1 = direction === "BUY" ? (level + 5).toFixed(2)  : (level - 5).toFixed(2);
    tp2 = direction === "BUY" ? (level + 10).toFixed(2) : (level - 10).toFixed(2);
    tp3 = direction === "BUY" ? (level + 15).toFixed(2) : (level - 15).toFixed(2);
    sl  = direction === "BUY" ? (level - 4).toFixed(2)  : (level + 4).toFixed(2);
  } else if (pair === "USOIL") {
    tp1 = direction === "BUY" ? (level + 0.30).toFixed(2) : (level - 0.30).toFixed(2);
    tp2 = direction === "BUY" ? (level + 0.60).toFixed(2) : (level - 0.60).toFixed(2);
    tp3 = direction === "BUY" ? (level + 0.90).toFixed(2) : (level - 0.90).toFixed(2);
    sl  = direction === "BUY" ? (level - 0.25).toFixed(2) : (level + 0.25).toFixed(2);
  } else {
    tp1 = direction === "BUY" ? (level + 80).toFixed(2)  : (level - 80).toFixed(2);
    tp2 = direction === "BUY" ? (level + 160).toFixed(2) : (level - 160).toFixed(2);
    tp3 = direction === "BUY" ? (level + 240).toFixed(2) : (level - 240).toFixed(2);
    sl  = direction === "BUY" ? (level - 60).toFixed(2)  : (level + 60).toFixed(2);
  }

  activeSignal = { pair, direction, entry, tp1, tp2, tp3, sl, time, mode: "MANUAL-TAP", status: "RUNNING" };

  const text =
`üìä ${pair}: ${direction}
‚öôÔ∏è MODE: MANUAL-TAP
üü° ENTRY: ${entry}
üéØ TP1: ${tp1} | TP2: ${tp2} | TP3: ${tp3}
üõë SL: ${sl}
üìç LIVE PRICE: ${price}
üìà TRADE IS LIVE...`;
  renderSignalUpper(text);
  speak(`${pair} ${direction}. Entry ${entry}. TP1 ${tp1}, TP2 ${tp2}, SL ${sl}`);
}

/* ==== Manual Button Generate ==== */
async function generateSignal() {
  const pair = pairSelect.value;

  if (activeSignal) {
    renderSignalUpper("‚è≥ WAIT: A SIGNAL IS ALREADY ACTIVE!");
    speak("Wait, a signal is already active");
    return;
  }
  if (isWeekendClosed(pair)) {
    renderSignalUpper(`‚ö†Ô∏è ${pair} MARKET IS CLOSED TODAY.`);
    speak("Market is closed today");
    return;
  }

  const price = await fetchLivePrice(pair);
  if (!price) return;

  const s = getSetup(pair, price);
  if (!s.inZone) {
    const msg =
`‚ùå NO VALID TRADE SETUP NOW.
PRICE NOT NEAR ANY KEY ZONE.
CURRENT: ${price}
${renderLevelsClickable(s.entryZones)}`;
    signalBox.innerHTML = msg.toUpperCase().replace(/\n/g, "<br>");
    speak("No trade now. Price not near level zone.");
    return;
  }

  const time = new Date().toLocaleTimeString("en-IN", { hour12: true });
  activeSignal = { pair, direction: s.direction, entry: s.entry, tp1: s.tp1, tp2: s.tp2, tp3: s.tp3, sl: s.sl, time, mode: "INTRADAY", status: "RUNNING" };
  const text =
`üìä ${pair}: ${s.direction}
‚öôÔ∏è MODE: INTRADAY
üü° ENTRY: ${s.entry}
üéØ TP1: ${s.tp1} | TP2: ${s.tp2} | TP3: ${s.tp3}
üõë SL: ${s.sl}
üìç LIVE PRICE: ${price}
üìà TRADE IS LIVE...`;
  renderSignalUpper(text);
  speak(`${pair} ${s.direction}. Entry ${s.entry}. TP1 ${s.tp1}, TP2 ${s.tp2}, SL ${s.sl}`);
}

/* ==== Auto Monitor (real-time) ==== */
async function autoMonitorTick() {
  if (activeSignal) return;
  const pair = pairSelect.value;
  if (isWeekendClosed(pair)) {
    renderSignalUpper(`‚ö†Ô∏è ${pair} MARKET IS CLOSED TODAY.`);
    return;
  }
  const price = await fetchLivePrice(pair);
  if (!price) return;

  const s = getSetup(pair, price);
  const baseHeader = `üõ∞Ô∏è AUTO MONITORING ACTIVE ‚Äî PAIR: ${pair} ‚Äî PRICE: ${price}`;
  if (!s.inZone) {
    const view =
`${baseHeader}
NO VALID SETUP NEAR ZONES.
${renderLevelsClickable(s.entryZones)}`;
    signalBox.innerHTML = view.toUpperCase().replace(/\n/g, "<br>");
    return;
  }

  // Found a potential setup ‚Üí mark pending & schedule execute after 10 minutes
  const nowStr = new Date().toLocaleTimeString("en-IN", { hour12: true });
  const pendingText =
`${baseHeader}
FOUND SETUP NEAR LEVEL ‚Äî MARKED AS PENDING
DIRECTION: ${s.direction}
PLANNED ENTRY: ${s.entry}
SL: ${s.sl} | TP1: ${s.tp1} | TP2: ${s.tp2} | TP3: ${s.tp3}
WILL AUTO-EXECUTE IN 10 MINUTES IF STILL VALID
DETECTED AT: ${nowStr}`;
  renderSignalUpper(pendingText);
  speak("Potential setup found. Will execute in ten minutes if still valid.");

  if (pendingTimer) { clearTimeout(pendingTimer); pendingTimer = null; }
  pendingTimer = setTimeout(async () => {
    if (activeSignal) return;
    const rePrice = await fetchLivePrice(pair);
    if (!rePrice) return;
    const re = getSetup(pair, rePrice);

    if (re.inZone) {
      const time = new Date().toLocaleTimeString("en-IN", { hour12: true });
      activeSignal = { pair, direction: re.direction, entry: re.entry, tp1: re.tp1, tp2: re.tp2, tp3: re.tp3, sl: re.sl, time, mode: "AUTO", status: "RUNNING" };
      const execText =
`üìä ${pair}: ${re.direction}
‚öôÔ∏è MODE: AUTO
üü° ENTRY: ${re.entry}
üéØ TP1: ${re.tp1} | TP2: ${re.tp2} | TP3: ${re.tp3}
üõë SL: ${re.sl}
üìç LIVE PRICE: ${rePrice}
‚úÖ AUTO-EXECUTED AFTER 10 MINUTES`;
      renderSignalUpper(execText);
      speak(`${pair} ${re.direction}. Entry ${re.entry}. TP1 ${re.tp1}, TP2 ${re.tp2}, SL ${re.sl}`);
    } else {
      const cancelText =
`${baseHeader}
SETUP INVALID AFTER 10 MINUTES ‚Äî AUTO EXECUTION CANCELLED
${renderLevelsClickable(re.entryZones)}`;
      signalBox.innerHTML = cancelText.toUpperCase().replace(/\n/g, "<br>");
      speak("Setup cancelled after recheck.");
    }
    pendingTimer = null;
  }, AUTO_DELAY_MS);
}

/* ==== Mode Switching ==== */
modeSelect.addEventListener("change", handleModeChange);
function handleModeChange() {
  const mode = modeSelect.value;
  if (pendingTimer) { clearTimeout(pendingTimer); pendingTimer = null; }
  if (autoMonitorId) { clearInterval(autoMonitorId); autoMonitorId = null; }

  if (mode === "AUTO") {
    renderSignalUpper("üõ∞Ô∏è AUTO MODE ON ‚Äî MONITORING LIVE PRICE...");
    autoMonitorId = setInterval(autoMonitorTick, MONITOR_EVERY_MS);
    autoMonitorTick();
  } else {
    renderSignalUpper("üñêÔ∏è MANUAL MODE ‚Äî TAP A LEVEL OR PRESS GENERATE SIGNAL");
  }
}
handleModeChange();

/* ==== Reset ==== */
function resetSignal() {
  if (pendingTimer) { clearTimeout(pendingTimer); pendingTimer = null; }
  activeSignal = null;
  renderSignalUpper("üîÑ RESET DONE. WAITING FOR SIGNAL...");
  speak("Reset done");
}

/* ==== Starfield animation ==== */
const canvas = document.getElementById("starfield");
const ctx = canvas.getContext("2d");
let stars = [];
function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resizeCanvas();
for (let i = 0; i < 200; i++) {
  stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2, speed: Math.random() * 1 });
}
function animateStars() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#00ffe7";
  stars.forEach(star => {
    star.y += star.speed;
    if (star.y > canvas.height) star.y = 0;
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.size, 0, 2 * Math.PI);
    ctx.fill();
  });
  requestAnimationFrame(animateStars);
}
animateStars();

/* ==== Clock ==== */
setInterval(() => {
  const now = new Date();
  timeDisplay.innerText = "‚è∞ CURRENT INDIAN TIME: " + now.toLocaleTimeString("en-IN").toUpperCase();
}, 1000);
</script>
</body>
</html>
