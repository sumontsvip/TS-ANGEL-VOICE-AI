<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TS Angel Forex AI</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: 'Arial', sans-serif;
      color: white;
      background: black;
    }
    canvas#starfield {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    body { text-align: center; padding: 20px; }
    h1 { color: #00ffe7; animation: neon-flicker 1.5s infinite; }
    #timeDisplay { font-size: 1.2rem; color: #ffcc00; animation: neon-flicker 2s infinite; }

    select, button {
      padding: 12px 20px; margin: 10px; font-size: 1rem;
      border-radius: 5px; background-color: #111; color: #00ffea;
      border: 2px solid #00ffea; cursor: pointer; animation: glow-pulse 2s infinite;
    }
    button:hover { background-color: #00ffea; color: black; }
    iframe {
      width: 100%; height: 500px; border: none; margin-top: 25px; border-radius: 10px;
      box-shadow: 0 0 20px #00ffe7; animation: glow-pulse 3s infinite;
    }
    .signal-box {
      margin-top: 25px; background: #111; padding: 20px; border-radius: 10px;
      font-size: 1.1rem; color: #ffcc00; animation: glow-pulse 1.5s infinite;
    }
    .watermark { margin-top: 40px; font-size: 1.2rem; color: #00ffe7; animation: neon-flicker 2s infinite; }

    .levels { margin-top: 10px; }
    .levels span {
      display: inline-block; margin: 6px 6px; padding: 6px 10px; border: 1px solid #00ffea;
      border-radius: 6px; cursor: pointer; user-select: none;
    }
    .levels span:hover { background:#00ffea; color:#000; }
    .muted { color:#8fe; font-size: 0.95rem; }

    @keyframes neon-flicker {
      0%, 100% { text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff; }
      50% { text-shadow: 0 0 2px #0ff, 0 0 5px #0ff; }
    }
    @keyframes glow-pulse {
      0%, 100% { box-shadow: 0 0 10px #00ffe7, 0 0 20px #00ffe7; }
      50% { box-shadow: 0 0 5px #00ffe7, 0 0 10px #00ffe7; }
    }
  </style>
</head>
<body>
<canvas id="starfield"></canvas>

<h1>üöÄ TS Angel Forex AI (BTC ‚Ä¢ GOLD ‚Ä¢ US OIL)</h1>
<p id="timeDisplay">‚è∞ Current Indian Time: </p>

<!-- Controls (unchanged layout spirit, just added mode & reset as requested earlier) -->
<select id="pairSelect">
  <option value="BTCUSD">BTCUSD</option>
  <option value="XAUUSD">XAUUSD</option>
  <option value="USOIL">USOIL</option>
</select>

<select id="modeSelect" title="Auto or Manual">
  <option value="MANUAL">MANUAL</option>
  <option value="AUTO">AUTO</option>
</select>

<button onclick="playClick(); generateSignal()">üì° Generate Signal</button>
<button onclick="resetSignal()">‚ôªÔ∏è Reset</button>

<div class="signal-box" id="signalBox">üîç Waiting for signal...</div>
<iframe id="tvChart"></iframe>

<div class="watermark">üí° Created by Trader Sumon</div>
<audio id="clickSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-click-1114.mp3"></audio>

<script>
/* ==== DOM ==== */
const pairSelect  = document.getElementById("pairSelect");
const modeSelect  = document.getElementById("modeSelect");
const tvChart     = document.getElementById("tvChart");
const signalBox   = document.getElementById("signalBox");
const timeDisplay = document.getElementById("timeDisplay");
const clickSound  = document.getElementById("clickSound");

/* ==== State ==== */
let activeSignal   = null;
let autoMonitorId  = null;
let pendingTimer   = null;
const MONITOR_EVERY_MS = 60 * 1000;   // 1 minute
const AUTO_DELAY_MS    = 10 * 60 * 1000; // 10 minutes (auto recheck + execute)

/* ==== Voice ==== */
function speak(text) {
  try {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'bn-IN';
    const voices = speechSynthesis.getVoices();
    const femaleVoice = voices.find(v => v.lang === 'bn-IN' && (v.name || '').toLowerCase().includes("female"));
    if (femaleVoice) utterance.voice = femaleVoice;
    speechSynthesis.speak(utterance);
  } catch {}
}
function playClick() { try { clickSound.play(); } catch {} }

/* ==== TradingView Chart ==== */
pairSelect.addEventListener("change", loadChart);
function loadChart() {
  const symbol = pairSelect.value;
  let tvSymbol = "OANDA:XAUUSD";
  if (symbol === "BTCUSD") tvSymbol = "BINANCE:BTCUSDT";
  if (symbol === "USOIL")  tvSymbol = "TVC:USOIL"; // TradingView symbol for WTI

  tvChart.src = `https://s.tradingview.com/widgetembed/?frameElementId=tvChart&symbol=${encodeURIComponent(tvSymbol)}&interval=5&theme=dark&style=1&timezone=Asia/Kolkata&withdateranges=1&studies=[]&toolbarbg=rgba(0,0,0,1)&hide_side_toolbar=0&allow_symbol_change=1&saveimage=1&details=1&hotlist=1&calendar=1&drawings_access=%7B%22type%22%3A%22black%22%7D`;
}
loadChart();

/* ==== Market Calendar ==== */
function isMarketClosed(pair) {
  const day = new Date().getDay(); // 0=Sun, 6=Sat
  if (pair === "XAUUSD" || pair === "USOIL") {
    return (day === 0 || day === 6); // weekends closed
  }
  if (pair === "BTCUSD") return false; // BTC 24/7
  return false;
}

/* ==== Live Price ==== */
const TD_API_KEY = "cd96961a49e242fe939a80866e70c57d"; // <-- keep/replace with your key

async function fetchLivePrice(pair) {
  try {
    if (pair === "BTCUSD") {
      const res  = await fetch("https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT");
      const data = await res.json();
      return parseFloat(data.price);
    } else if (pair === "XAUUSD") {
      const res  = await fetch(`https://api.twelvedata.com/price?symbol=XAU/USD&apikey=${TD_API_KEY}`);
      const data = await res.json();
      if (!data || !data.price) throw new Error("TwelveData XAU error");
      return parseFloat(data.price);
    } else if (pair === "USOIL") {
      // TwelveData supports WTI with symbol "CL=F" (futures) or "WTI/USD" on some feeds.
      // We'll try CL=F first. If your plan doesn't allow, switch to "WTI/USD".
      const res  = await fetch(`https://api.twelvedata.com/price?symbol=CL=F&apikey=${TD_API_KEY}`);
      const data = await res.json();
      if (!data || !data.price) throw new Error("TwelveData OIL error");
      return parseFloat(data.price);
    }
  } catch (error) {
    signalBox.innerHTML = "‚ùå ERROR FETCHING LIVE PRICE!";
    console.error(error);
    return null;
  }
}

/* ==== Helper: Render ==== */
function renderSignalUpper(text) {
  signalBox.innerHTML = text.toUpperCase().replace(/\n/g, "<br>");
}
function renderLevelsClickable(levels=[]) {
  if (!levels.length) return "";
  return `<div class="levels"><span class="muted">Tap level to execute:</span><br>${
    levels.map(l => `<span data-lvl="${l}" title="Tap to execute at level">${l}</span>`).join(" ")
  }</div>`;
}
signalBox.addEventListener("click", (e) => {
  const span = e.target.closest("span[data-lvl]");
  if (!span) return;
  const lvl = parseFloat(span.getAttribute("data-lvl"));
  tapExecuteAtLevel(lvl);
});

/* ==== GOLD (same style as your original, zones + momentum) ==== */
function getGoldSetup(price) {
  const dailyBias    = price > 3350.5 ? "BUY" : "SELL";
  const momentumSell = price < 3377.28;
  const momentumBuy  = price > 3377.28;
  const sellZones = [3372, 3370, 3365, 3360, 3356, 3351];
  const buyZones  = [3381, 3385, 3389, 3394];
  const entryZones = momentumSell ? sellZones : buyZones;

  const inZone = entryZones.some(level => Math.abs(price - level) <= 0.5);
  const direction = momentumSell ? "SELL" : "BUY";

  const entry = parseFloat(price.toFixed(2));
  const tp1   = direction === "BUY" ? (entry + 5).toFixed(2)  : (entry - 5).toFixed(2);
  const tp2   = direction === "BUY" ? (entry + 10).toFixed(2) : (entry - 10).toFixed(2);
  const tp3   = direction === "BUY" ? (entry + 15).toFixed(2) : (entry - 15).toFixed(2);
  const sl    = direction === "BUY" ? (entry - 4).toFixed(2)  : (entry + 4).toFixed(2);

  return { dailyBias, momentumBuy, momentumSell, entryZones, inZone, direction, entry, tp1, tp2, tp3, sl };
}

/* ==== BTC (same style as GOLD, but dynamic zones around pivot so random feel chole jay) ==== */
function getBTCSetup(price) {
  // Pivot = nearest 1000 + 500 (e.g., 65320 -> 65500)
  const nearestThousand = Math.floor(price / 1000) * 1000;
  const pivot = nearestThousand + 500;

  const momentumSell = price < pivot;
  const momentumBuy  = price >= pivot;
  const direction    = momentumSell ? "SELL" : "BUY";

  // Dynamic zones: ¬±200, ¬±400, ¬±600, ¬±800 from pivot
  const sellZones = [pivot - 200, pivot - 400, pivot - 600, pivot - 800];
  const buyZones  = [pivot + 200, pivot + 400, pivot + 600, pivot + 800];
  const entryZones = momentumSell ? sellZones : buyZones;

  // BTC band wider
  const inZone = entryZones.some(level => Math.abs(price - level) <= 20);

  const entry = parseFloat(price.toFixed(2));
  const tp1   = direction === "BUY" ? (entry + 100).toFixed(2) : (entry - 100).toFixed(2);
  const tp2   = direction === "BUY" ? (entry + 200).toFixed(2) : (entry - 200).toFixed(2);
  const tp3   = direction === "BUY" ? (entry + 300).toFixed(2) : (entry - 300).toFixed(2);
  const sl    = direction === "BUY" ? (entry - 80).toFixed(2)  : (entry + 80).toFixed(2);

  return { pivot, momentumBuy, momentumSell, entryZones, inZone, direction, entry, tp1, tp2, tp3, sl };
}

/* ==== US OIL (same pattern as GOLD; dynamic zones around round dollars) ==== */
function getOilSetup(price) {
  // Pivot = nearest whole + 0.50 (e.g., 82.34 -> 82.50)
  const nearestWhole = Math.floor(price);
  const pivot = nearestWhole + 0.5;

  const momentumSell = price < pivot;
  const momentumBuy  = price >= pivot;
  const direction    = momentumSell ? "SELL" : "BUY";

  // Zones every 0.50 / 1.00 around pivot
  const sellZones = [pivot - 0.5, pivot - 1.0, pivot - 1.5, pivot - 2.0];
  const buyZones  = [pivot + 0.5, pivot + 1.0, pivot + 1.5, pivot + 2.0];
  const entryZones = momentumSell ? sellZones : buyZones;

  const inZone = entryZones.some(level => Math.abs(price - level) <= 0.08);

  const entry = parseFloat(price.toFixed(2));
  const tp1   = direction === "BUY" ? (entry + 0.20).toFixed(2) : (entry - 0.20).toFixed(2);
  const tp2   = direction === "BUY" ? (entry + 0.40).toFixed(2) : (entry - 0.40).toFixed(2);
  const tp3   = direction === "BUY" ? (entry + 0.60).toFixed(2) : (entry - 0.60).toFixed(2);
  const sl    = direction === "BUY" ? (entry - 0.18).toFixed(2) : (entry + 0.18).toFixed(2);

  return { pivot, momentumBuy, momentumSell, entryZones, inZone, direction, entry, tp1, tp2, tp3, sl };
}

/* ==== Manual Tap Execute (common) ==== */
async function tapExecuteAtLevel(level) {
  const pair  = pairSelect.value;
  const price = await fetchLivePrice(pair);
  if (price == null) return;

  if (isMarketClosed(pair)) {
    renderSignalUpper(`‚ö†Ô∏è ${pair} MARKET IS CLOSED TODAY.`);
    speak(`${pair} market is closed today`);
    return;
  }

  const time = new Date().toLocaleTimeString("en-IN", { hour12: true });
  // Direction: simple tap idea ‚Äî if current <= level ‚Üí BUY, else SELL
  const direction = price <= level ? "BUY" : "SELL";
  const entry = level.toFixed(2);

  // TP/SL distances depend on pair
  let tp1, tp2, tp3, sl;
  if (pair === "XAUUSD") {
    tp1 = direction === "BUY" ? (level + 5).toFixed(2)  : (level - 5).toFixed(2);
    tp2 = direction === "BUY" ? (level + 10).toFixed(2) : (level - 10).toFixed(2);
    tp3 = direction === "BUY" ? (level + 15).toFixed(2) : (level - 15).toFixed(2);
    sl  = direction === "BUY" ? (level - 4).toFixed(2)  : (level + 4).toFixed(2);
  } else if (pair === "BTCUSD") {
    tp1 = direction === "BUY" ? (level + 100).toFixed(2) : (level - 100).toFixed(2);
    tp2 = direction === "BUY" ? (level + 200).toFixed(2) : (level - 200).toFixed(2);
    tp3 = direction === "BUY" ? (level + 300).toFixed(2) : (level - 300).toFixed(2);
    sl  = direction === "BUY" ? (level - 80).toFixed(2)  : (level + 80).toFixed(2);
  } else {
    // USOIL
    tp1 = direction === "BUY" ? (level + 0.20).toFixed(2) : (level - 0.20).toFixed(2);
    tp2 = direction === "BUY" ? (level + 0.40).toFixed(2) : (level - 0.40).toFixed(2);
    tp3 = direction === "BUY" ? (level + 0.60).toFixed(2) : (level - 0.60).toFixed(2);
    sl  = direction === "BUY" ? (level - 0.18).toFixed(2) : (level + 0.18).toFixed(2);
  }

  activeSignal = { pair, direction, entry, tp1, tp2, tp3, sl, time, mode: "MANUAL-TAP", status: "RUNNING" };

  const text = 
`üìä ${pair}: ${direction}
‚öôÔ∏è MODE: MANUAL-TAP
üü° ENTRY: ${entry}
üéØ TP1: ${tp1} | TP2: ${tp2} | TP3: ${tp3}
üõë SL: ${sl}
üìç LIVE PRICE: ${price.toFixed(2)}
üìà TRADE IS LIVE...`;
  renderSignalUpper(text);
  speak(`${pair} ${direction}. Entry ${entry}. TP1 ${tp1}, TP2 ${tp2}, SL ${sl}`);
}

/* ==== Manual Button Generate (Gold-like logic shared to BTC & OIL) ==== */
async function generateSignal() {
  const pair = pairSelect.value;
  const time = new Date().toLocaleTimeString("en-IN", { hour12: true });

  if (activeSignal) {
    renderSignalUpper("‚è≥ WAIT: A SIGNAL IS ALREADY ACTIVE!");
    speak("Wait, a signal is already active");
    return;
  }
  if (isMarketClosed(pair)) {
    renderSignalUpper(`‚ö†Ô∏è ${pair} MARKET IS CLOSED TODAY.`);
    speak(`${pair} market is closed today`);
    return;
  }

  const price = await fetchLivePrice(pair);
  if (!price) return;

  let s, levelsText = "";
  if (pair === "XAUUSD") {
    s = getGoldSetup(price);
    levelsText = renderLevelsClickable(s.entryZones);
    if (!s.inZone) {
      const msg = 
`‚ùå NO VALID TRADE SETUP NOW.
PRICE NOT NEAR ANY KEY ZONE.
CURRENT: ${price.toFixed(2)}
${levelsText}`;
      signalBox.innerHTML = msg.toUpperCase().replace(/\n/g, "<br>");
      speak("No trade now. Price not near level zone.");
      return;
    }
  } else if (pair === "BTCUSD") {
    s = getBTCSetup(price);
    levelsText = renderLevelsClickable(s.entryZones);
    if (!s.inZone) {
      const msg = 
`‚ùå NO VALID TRADE SETUP NOW.
PRICE NOT NEAR ANY KEY ZONE.
CURRENT: ${price.toFixed(2)}
${levelsText}`;
      signalBox.innerHTML = msg.toUpperCase().replace(/\n/g, "<br>");
      speak("No trade now. Price not near level zone.");
      return;
    }
  } else { // USOIL
    s = getOilSetup(price);
    levelsText = renderLevelsClickable(s.entryZones);
    if (!s.inZone) {
      const msg = 
`‚ùå NO VALID TRADE SETUP NOW.
PRICE NOT NEAR ANY KEY ZONE.
CURRENT: ${price.toFixed(2)}
${levelsText}`;
      signalBox.innerHTML = msg.toUpperCase().replace(/\n/g, "<br>");
      speak("No trade now. Price not near level zone.");
      return;
    }
  }

  activeSignal = { pair, direction: s.direction, entry: s.entry, tp1: s.tp1, tp2: s.tp2, tp3: s.tp3, sl: s.sl, time, mode: "INTRADAY", status: "RUNNING" };
  const text =
`üìä ${pair}: ${s.direction}
‚öôÔ∏è MODE: INTRADAY
üü° ENTRY: ${s.entry}
üéØ TP1: ${s.tp1} | TP2: ${s.tp2} | TP3: ${s.tp3}
üõë SL: ${s.sl}
üìç LIVE PRICE: ${price.toFixed(2)}
üìà TRADE IS LIVE...`;
  renderSignalUpper(text);
  speak(`${pair} ${s.direction}. Entry ${s.entry}. TP1 ${s.tp1}, TP2 ${s.tp2}, SL ${s.sl}`);
}

/* ==== Auto Monitor (real-time) ==== */
async function autoMonitorTick() {
  if (activeSignal) return; // don't spawn another
  const pair = pairSelect.value;
  if (isMarketClosed(pair)) {
    renderSignalUpper(`‚ö†Ô∏è ${pair} MARKET IS CLOSED TODAY.`);
    return;
  }

  const price = await fetchLivePrice(pair);
  if (!price) return;

  let s;
  if (pair === "XAUUSD") s = getGoldSetup(price);
  else if (pair === "BTCUSD") s = getBTCSetup(price);
  else s = getOilSetup(price);

  const baseHeader = `üõ∞Ô∏è AUTO MONITORING ‚Äî PAIR: ${pair} ‚Äî PRICE: ${price.toFixed(2)}`;
  if (!s.inZone) {
    const view =
`${baseHeader}
NO VALID SETUP NEAR ZONES.
${renderLevelsClickable(s.entryZones)}`;
    signalBox.innerHTML = view.toUpperCase().replace(/\n/g, "<br>");
    return;
  }

  // Found potential setup ‚Üí mark pending & schedule execute after 10 minutes
  const nowStr = new Date().toLocaleTimeString("en-IN", { hour12: true });
  const pendingText =
`${baseHeader}
FOUND SETUP NEAR LEVEL ‚Äî MARKED AS PENDING
DIRECTION: ${s.direction}
PLANNED ENTRY: ${s.entry}
SL: ${s.sl} | TP1: ${s.tp1} | TP2: ${s.tp2} | TP3: ${s.tp3}
WILL AUTO-EXECUTE IN 10 MINUTES IF STILL VALID
DETECTED AT: ${nowStr}`;
  renderSignalUpper(pendingText);
  speak("Potential setup found. Will execute in ten minutes if still valid.");

  if (pendingTimer) { clearTimeout(pendingTimer); pendingTimer = null; }
  pendingTimer = setTimeout(async () => {
    if (activeSignal) return;
    const rePrice = await fetchLivePrice(pair);
    if (!rePrice) return;

    let re;
    if (pair === "XAUUSD") re = getGoldSetup(rePrice);
    else if (pair === "BTCUSD") re = getBTCSetup(rePrice);
    else re = getOilSetup(rePrice);

    if (re.inZone) {
      const time = new Date().toLocaleTimeString("en-IN", { hour12: true });
      activeSignal = { pair, direction: re.direction, entry: re.entry, tp1: re.tp1, tp2: re.tp2, tp3: re.tp3, sl: re.sl, time, mode: "AUTO", status: "RUNNING" };
      const execText =
`üìä ${pair}: ${re.direction}
‚öôÔ∏è MODE: AUTO
üü° ENTRY: ${re.entry}
üéØ TP1: ${re.tp1} | TP2: ${re.tp2} | TP3: ${re.tp3}
üõë SL: ${re.sl}
üìç LIVE PRICE: ${rePrice.toFixed(2)}
‚úÖ AUTO-EXECUTED AFTER 10 MINUTES`;
      renderSignalUpper(execText);
      speak(`${pair} ${re.direction}. Entry ${re.entry}. TP1 ${re.tp1}, TP2 ${re.tp2}, SL ${re.sl}`);
    } else {
      const cancelText =
`${baseHeader}
SETUP INVALID AFTER 10 MINUTES ‚Äî AUTO EXECUTION CANCELLED
${renderLevelsClickable(re.entryZones)}`;
      signalBox.innerHTML = cancelText.toUpperCase().replace(/\n/g, "<br>");
      speak("Setup cancelled after recheck.");
    }
    pendingTimer = null;
  }, AUTO_DELAY_MS);
}

/* ==== Mode Switching ==== */
modeSelect.addEventListener("change", handleModeChange);
function handleModeChange() {
  const mode = modeSelect.value;
  if (pendingTimer) { clearTimeout(pendingTimer); pendingTimer = null; }
  if (autoMonitorId) { clearInterval(autoMonitorId); autoMonitorId = null; }

  if (mode === "AUTO") {
    renderSignalUpper("üõ∞Ô∏è AUTO MODE ON ‚Äî MONITORING LIVE PRICE...");
    autoMonitorId = setInterval(autoMonitorTick, MONITOR_EVERY_MS);
    autoMonitorTick(); // run once immediately
  } else {
    renderSignalUpper("üñêÔ∏è MANUAL MODE ‚Äî TAP A LEVEL OR PRESS GENERATE SIGNAL");
  }
}
handleModeChange();

/* ==== Reset ==== */
function resetSignal() {
  if (pendingTimer) { clearTimeout(pendingTimer); pendingTimer = null; }
  if (autoMonitorId && modeSelect.value === "AUTO") {
    clearInterval(autoMonitorId);
    autoMonitorId = setInterval(autoMonitorTick, MONITOR_EVERY_MS); // keep auto mode alive
  }
  activeSignal = null;
  renderSignalUpper("üîÑ RESET DONE. WAITING FOR SIGNAL...");
  speak("Reset done");
}

/* ==== Starfield animation (unchanged) ==== */
const canvas = document.getElementById("starfield");
const ctx = canvas.getContext("2d");
let stars = [];
function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resizeCanvas();
for (let i = 0; i < 200; i++) {
  stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2, speed: Math.random() * 1 });
}
function animateStars() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#00ffe7";
  stars.forEach(star => {
    star.y += star.speed;
    if (star.y > canvas.height) star.y = 0;
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.size, 0, 2 * Math.PI);
    ctx.fill();
  });
  requestAnimationFrame(animateStars);
}
animateStars();

/* ==== Clock ==== */
setInterval(() => {
  const now = new Date();
  timeDisplay.innerText = "‚è∞ Current Indian Time: " + now.toLocaleTimeString("en-IN");
}, 1000);
</script>
</body>
</html>
